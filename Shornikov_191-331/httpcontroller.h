#ifndef HTTPCONTROLLER_H
#define HTTPCONTROLLER_H

#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include "friendsmodel.h"

class HTTPController : public QObject
{
    Q_OBJECT

public:
    ~HTTPController()
    {
        // Kill them (dynamic variables) all!!!
        delete nam;
        delete proto;
        delete reply;
        delete modelController;
    }
    explicit HTTPController(QObject *parent = nullptr);

    // Вместо глоб. переменной - свойство класса.
    QNetworkAccessManager * nam = nullptr;
    QString access_token;
    friendsModel *modelController; // модель для ЛР_5.
public slots:
    void sendPageInfo();
    void getPageInfo();
    void messageController();
    QString getToken(QString url); // Для получения токена.
    void restCall(); // Для ЛР_5, получение 10 случайных друзей из списка.
signals:
    void sendMessage(QString msg); // Для проверки работы сигналов.
protected:
    QObject* proto;
    QNetworkReply* reply;
};

/*
 * Типы связывания библиотек:
 * 1) Когда весь код содержится в cpp и h файлах и для его подключения достаточно только объявить include
 *  Это header-only (загол. библиотека)
 *   + Ток include.
 *   + Кроссплатформенность.
 *   - Код библиотеки всегда перестраивается при перестройке самой программы, к которой подк. библ.
 *   - Размер приложения увеличивается за счёт включения кода, скомп. из .h и .cpp.
 *  Библиотеки данного типа следует исп. для кода небольшого размера либо для прототипов, когда нет времени
 *  для разделения на .lib.
 *
 * 2) Статическое связывание.
 *  Код библиотек заранее скомпилен в .lib файлы (win), .a (unix).
 *  Для подключения необходимо:
 *   1. Дать команду сборщику искать код функций в соответствующих .lib-файлах.
 *   2. Подключить заголовки *.h .
 *  По h-файлам компилятор проверяет правильность передачи параметров в функции, хран. в .lib.
 *  При сборке (linking) фрагменты кода из lib копируются в приложение.
 *   + код не перестраивается при пересборке приложения, ускоряет сборку приложения.
 *   - размер приложения увеличивается за счёт включения кода из .lib.
 *   - под каждую платформу должен быть получен свой .lib-файл.
 *
 * 3) Динамическое (явное)
 *  Код библиотеки собирается в диманическую библ. .dll (windows), .so (unix).
 *  Для подключения библиотеки приложения необходимо:
 *   1. Разместить dll в каталоге приложения либо в одном из каталогов PATH, либо добавить в PATH каталог с dll.
 *   2. Дать команду сборщику (linker) исп. .lib-файл, который получен в паре с dll, для получения адресов
 *   функций из dll (lib-файл с таблицой импорта).
 *   3. Подключить заголовки *.h.
 *  По h-файлам компилятор проверяет правильность передачи параметров в функции, хран. в .lib.
 *  .lib содержит не код, а специальную таблицу, которую сборщик учитывает. выстраивая связи
 *  между кодом приложения и кодом функций из dll.
 *  Сами dll с машинным кодом функций загружаются ОС перед запуском приложения на основе информации из
 *  заголовка приложения о зависимости.
 *
 * 4) Динамическое (неявное)
 *  Отличается от п.3 тем, что:
 *   1. Не нужны .lib-файлы с таблицами импорта для поиска функций в dll.
 *   2. dll грузится в память не при старте приложения ОС, а по отдельной команде, прописанной
 *   в самом приложении в произвольный момент времени. В Win - LoadLibrary и GetProcAddress.
 *
 *  Дин. неявное, применяется чаще всего для плагинов приложений.
 *  Дин. явное, наиболее часто встречаемый тип привязки библиотек.
 *   + Одной и той же dll могут одновременно пользоваться разные приложения (решается проблема избыточности,
 *   замечание: если приложениям необходимы разные версии dll, то совместимость теряется и на машине нужно развернуть
 *   все необходимые файлы).
 *   - Код библиотеки хран. в виде отдельного файла и он может "потеряться".
 */

#endif // HTTPCONTROLLER_H
